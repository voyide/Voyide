<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Page Title and Meta Tags for SEO -->
    <title>looking for me? ^_^</title>
    <meta name="description" content="couldnt avoyide the urge to search huh?">
    <meta name="keywords" content="voyide, the voyide, looking for me, void, voyid, a voyide, voyide meaning, interactive art, digital experience">
    <meta name="author" content="Voyide Explorer">

    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "looking for me in the voyide",
      "description": "well ? fuck off now -_- ",
      "mainEntity": {
        "@type": "ImageObject",
        "name": "Image from the Voyide",
        "description": "A mysterious image representing the voyide.",
        "contentUrl": "void.jpg",
        "author": "Voyide Explorer",
        "encodingFormat": "image/jpeg",
        "isFamilyFriendly": "true"
      }
    }
    </script>

    <style>
        :root {
            --glow-color: rgba(132, 0, 255, 0.75);
            --card-bg: #1a1a1a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'system-ui', sans-serif;
            background-color: #000000;
            color: #e0e0e0;
            overflow: hidden;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
        }

        #particle-canvas {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
        }

        .perspective-container {
            perspective: 1500px;
            z-index: 10;
        }

        .card {
            width: 90vw;
            max-width: 500px;
            /* We determine height via JS based on aspect ratio, or set a min-height */
            min-height: 300px; 
            background: var(--card-bg);
            border-radius: 20px;
            padding: 20px;
            transform-style: preserve-3d;
            position: relative;
            
            /* The magical glow effect */
            box-shadow: 
                0 0 10px rgba(0,0,0,0.5),
                0 0 20px var(--glow-color),
                0 0 35px var(--glow-color),
                0 0 50px var(--glow-color);
        }

        /* Container for the fragmented image */
        .fragment-wrapper {
            position: relative;
            width: 100%;
            /* Aspect ratio placeholder - adjust padding-bottom to match your image ratio 
               e.g., 56.25% for 16:9, 100% for square. 75% is 4:3 */
            padding-bottom: 100%; 
            transform-style: preserve-3d;
            cursor: crosshair;
        }

        /* The hidden original image (kept for SEO and dimensions) */
        #source-img {
            display: none;
        }

        /* Individual grid pieces */
        .grid-cell {
            position: absolute;
            background-size: cover;
            backface-visibility: hidden;
            transform-style: preserve-3d;
            will-change: transform, opacity;
            /* Smooth return to original state */
            transition: transform 1.5s cubic-bezier(0.075, 0.82, 0.165, 1), opacity 1s ease;
        }

        .content {
            padding-top: 25px;
            transform-style: preserve-3d;
        }

        h1 {
            font-size: 2rem;
            text-shadow: 0 0 10px var(--glow-color);
            transform: translateZ(40px);
        }

        p {
            margin-top: 10px;
            opacity: 0.8;
            transform: translateZ(30px);
        }

    </style>
</head>
<body>

    <canvas id="particle-canvas"></canvas>

    <div class="perspective-container">
        <div class="card" id="interactive-card">
            
            <!-- Image Wrapper -->
            <div class="fragment-wrapper" id="fragment-container">
                <!-- Real image is hidden, used as data source -->
                <img id="source-img" src="void.jpg" alt="it is I, voyide" onload="initFragmenter()">
            </div>

            <div class="content">
                <h1> what u looking for stalker</h1>
                <p> GET LOST! -_- </p>
            </div>
        </div>
    </div>

    <script>
        // CONFIGURATION
        const GRID_ROWS = 10; // Higher = more pieces (CPU intensive)
        const GRID_COLS = 10;
        
        // --- 1. THE FRAGMENTER (Special Effects) ---
        
        const container = document.getElementById('fragment-container');
        const img = document.getElementById('source-img');
        let pieces = [];
        let chaosSeed = Math.random(); // Randomizes the effect type on load

        function initFragmenter() {
            // Wait for image to load to ensure we can display it
            if (!img.complete) return;

            // Adjust aspect ratio of container to match image
            const aspectRatio = (img.naturalHeight / img.naturalWidth) * 100;
            container.style.paddingBottom = `${aspectRatio}%`;

            const width = 100 / GRID_COLS;
            const height = 100 / GRID_ROWS;

            // Create grid
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    
                    // Dimensions and position
                    cell.style.width = `${width}%`;
                    cell.style.height = `${height}%`;
                    cell.style.left = `${c * width}%`;
                    cell.style.top = `${r * height}%`;
                    
                    // Background Image Slicing
                    cell.style.backgroundImage = `url('${img.src}')`;
                    cell.style.backgroundPosition = `${c * (100 / (GRID_COLS - 1))}% ${r * (100 / (GRID_ROWS - 1))}%`;
                    cell.style.backgroundSize = `${GRID_COLS * 100}% ${GRID_ROWS * 100}%`;

                    // PROCEDURAL SCATTER (The "Load" Effect)
                    // We set initial chaotic transforms
                    const randomX = (Math.random() - 0.5) * 800;
                    const randomY = (Math.random() - 0.5) * 800;
                    const randomZ = (Math.random() * 1000) + 200;
                    const randomRotX = Math.random() * 360;
                    const randomRotY = Math.random() * 360;
                    
                    cell.style.transform = `
                        translate3d(${randomX}px, ${randomY}px, ${randomZ}px) 
                        rotateX(${randomRotX}deg) 
                        rotateY(${randomRotY}deg)
                    `;
                    cell.style.opacity = '0';

                    // Store logic data for hover effects
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    container.appendChild(cell);
                    pieces.push(cell);
                }
            }

            // TRIGGER ASSEMBLY ANIMATION
            // Slight delay to ensure the browser renders the scattered state first
            setTimeout(() => {
                pieces.forEach((piece, index) => {
                    // Stagger the assembly slightly for a "whoosh" effect
                    setTimeout(() => {
                        piece.style.transform = 'translate3d(0,0,20px) rotate(0deg)'; // 20px pop out
                        piece.style.opacity = '1';
                    }, index * 2); // 2ms delay per piece
                });
            }, 100);
        }

        // --- 2. HOVER INTERACTION (The "Touch" Effect) ---
        
        const card = document.getElementById('interactive-card');
        let mouseX = 0;
        let mouseY = 0;
        let isHovering = false;

        // Update randomness every time we enter the card
        card.addEventListener('mouseenter', () => {
            isHovering = true;
            chaosSeed = Math.random(); // New effect pattern every touch
            
            // Faster transition for responsiveness during hover
            pieces.forEach(p => p.style.transition = 'transform 0.2s ease-out');
        });

        card.addEventListener('mouseleave', () => {
            isHovering = false;
            // Slower transition for assembling back
            pieces.forEach(p => {
                p.style.transition = 'transform 1.5s cubic-bezier(0.075, 0.82, 0.165, 1)';
                p.style.transform = 'translate3d(0,0,20px) rotate(0deg)';
            });
            // Reset Card Tilt
            card.style.transform = 'rotateX(0deg) rotateY(0deg)';
        });

        card.addEventListener('mousemove', (e) => {
            const rect = container.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            // CARD TILT LOGIC (Preserved)
            const cardRect = card.getBoundingClientRect();
            const cx = cardRect.width / 2;
            const cy = cardRect.height / 2;
            const rotY = ((e.clientX - cardRect.left) - cx) / cx * 10;
            const rotX = -((e.clientY - cardRect.top) - cy) / cy * 10;
            card.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;

            if(isHovering) applyHoverEffect(rect.width, rect.height);
        });

        function applyHoverEffect(w, h) {
            pieces.forEach(piece => {
                // Calculate center of this piece
                const r = parseInt(piece.dataset.r);
                const c = parseInt(piece.dataset.c);
                const pieceX = (c / GRID_COLS) * w + (w / GRID_COLS / 2);
                const pieceY = (r / GRID_ROWS) * h + (h / GRID_ROWS / 2);

                // Distance from mouse to piece
                const dx = mouseX - pieceX;
                const dy = mouseY - pieceY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Interaction Radius
                const maxDist = 150; 

                if (dist < maxDist) {
                    // Calculate Force (0 to 1)
                    const force = (maxDist - dist) / maxDist;

                    // GENERATE UNIQUE EFFECTS BASED ON CHAOS SEED
                    let tx = 0, ty = 0, tz = 0, rx = 0, ry = 0;

                    if (chaosSeed < 0.33) {
                        // MODE 1: The "Repel" (Explosion)
                        tx = -dx * force * 0.5;
                        ty = -dy * force * 0.5;
                        tz = force * 100;
                        rx = dy * force;
                        ry = -dx * force;
                    } else if (chaosSeed < 0.66) {
                        // MODE 2: The "Sinkhole" (Twist In)
                        tz = -force * 150;
                        rx = force * 90; // Flip
                        // Spiral effect
                        tx = Math.sin(force * Math.PI) * 20; 
                    } else {
                        // MODE 3: The "Digital Glitch" (Random Snaps)
                        if (Math.random() > 0.5) {
                            tx = (Math.random() - 0.5) * 50 * force;
                            ty = (Math.random() - 0.5) * 50 * force;
                            tz = force * 200;
                        }
                    }

                    piece.style.transform = `translate3d(${tx}px, ${ty}px, ${20 + tz}px) rotateX(${rx}deg) rotateY(${ry}deg)`;
                } else {
                    // Return to near-normal if outside radius
                    piece.style.transform = 'translate3d(0,0,20px)';
                }
            });
        }


        // --- 3. BACKGROUND PARTICLES (Preserved) ---
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let particlesArray = [];

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = (Math.random() * 2) + 0.5;
                this.speedX = (Math.random() * 0.4) - 0.2;
                this.speedY = (Math.random() * 0.4) - 0.2;
                this.color = 'rgba(255, 255, 255, 0.6)';
            }
            update() {
                if (this.x > canvas.width || this.x < 0) this.speedX *= -1;
                if (this.y > canvas.height || this.y < 0) this.speedY *= -1;
                this.x += this.speedX;
                this.y += this.speedY;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initParticles() {
            particlesArray = [];
            let numberOfParticles = (canvas.height * canvas.width) / 9000;
            for (let i = 0; i < numberOfParticles; i++) particlesArray.push(new Particle());
        }

        function animateParticles() {
            requestAnimationFrame(animateParticles);
            ctx.clearRect(0, 0, innerWidth, innerHeight);
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
                particlesArray[i].draw();
            }
        }

        window.addEventListener('resize', () => {
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            initParticles();
        });

        initParticles();
        animateParticles();

    </script>
</body>
</html>
